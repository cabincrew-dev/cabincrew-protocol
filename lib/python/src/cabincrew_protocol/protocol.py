# generated by datamodel-codegen:
#   filename:  schema.json
#   timestamp: 2025-12-10T05:35:04+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Optional, Union

from pydantic import AwareDatetime, BaseModel, ConfigDict, RootModel


class Model(RootModel[Any]):
    root: Any


class PlanArtifactHash(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: str
    hash: str
    size: Optional[float] = None


class PlanToken(BaseModel):
    """
    Plan-token binds artifacts to subsequent take-off.
    Extended with version and governance provenance for safe upgrades and auditability.
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    token: str
    """
    Primary plan token identifier, e.g. SHA256 over all plan artifacts + context.
    """
    version: str
    """
    Plan-token format version.
    REQUIRED for forward-compatibility handshake in mixed-version deployments.
    Format: "1", "2", etc. (semantic versioning for plan-token structure)
    """
    artifacts: list[PlanArtifactHash]
    """
    Per-artifact hashes that contributed to this plan token.
    """
    model: str
    """
    AI Model identifier used to generate this plan (e.g. 'gpt-4', 'claude-3').
    Required for provenance.
    """
    engine_id: str
    """
    Engine identity that produced this plan.
    """
    protocol_version: str
    """
    Engine protocol version used when this plan was produced.
    """
    workspace_hash: str
    """
    Hash of the workspace state when the plan was created.
    """
    created_at: AwareDatetime
    """
    Timestamp when the plan was created (RFC3339).
    """
    policy_digest: Optional[str] = None
    """
    SHA256 digest of all policy configurations evaluated during flight-plan.
    OPTIONAL but recommended for governance provenance.
    Proves which policy set was active when plan-token was created.
    """
    governance_hash: Optional[str] = None
    """
    SHA256 hash of governance context (OPA policies, ONNX models, gateway rules).
    OPTIONAL but recommended for compliance verification.
    Enables auditors to verify governance configuration at plan-time.
    """


class RecordStringAny(BaseModel):
    """
    Generic record type for arbitrary key-value pairs.
    Used for config, context, metadata, evidence, etc.
    """

    model_config = ConfigDict(
        extra='allow',
    )


class PreflightEvidence(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: str
    path: str
    hash: str


class Mode(Enum):
    flight_plan = 'flight-plan'
    take_off = 'take-off'


class PreflightInput(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    workflow_id: str
    step_id: str
    mode: Mode
    engine_output: RecordStringAny
    evidence: Optional[list[PreflightEvidence]] = None
    context: Optional[RecordStringAny] = None
    plan_token: Optional[PlanToken] = None
    """
    Plan-token binds artifacts to subsequent take-off.
    Extended with version and governance provenance for safe upgrades and auditability.
    """


class PreflightRequires(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    role: Optional[str] = None
    reason: Optional[str] = None


class Decision(Enum):
    allow = 'allow'
    deny = 'deny'
    require_approval = 'require_approval'
    warn = 'warn'


class PreflightOutput(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    decision: Decision
    violations: Optional[list[str]] = None
    warnings: Optional[list[str]] = None
    requires: Optional[PreflightRequires] = None


class ApprovalRequest(BaseModel):
    """
    Request for human approval before proceeding with execution.

    Security: The plan_token_hash MUST be verified to match the current plan-token
    to prevent approval replay attacks against mutated plans.
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    approval_id: str
    workflow_id: str
    step_id: str
    reason: str
    required_role: str
    engine_output: Optional[RecordStringAny] = None
    evidence: Optional[list[PreflightEvidence]] = None
    plan_token_hash: str
    """
    SHA256 hash of the plan-token that this approval is bound to.
    REQUIRED to prevent approval replay attacks.
    The orchestrator MUST verify this matches the current plan-token before accepting approval.
    """


class ApprovalResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    approval_id: str
    approved: bool
    approver: Optional[str] = None
    reason: Optional[str] = None
    timestamp: Optional[str] = None


class State(Enum):
    APPROVED = 'APPROVED'
    ARTIFACTS_VALIDATED = 'ARTIFACTS_VALIDATED'
    AWAITING_APPROVAL = 'AWAITING_APPROVAL'
    COMPLETED = 'COMPLETED'
    EXECUTION_COMPLETE = 'EXECUTION_COMPLETE'
    FAILED = 'FAILED'
    INIT = 'INIT'
    PLAN_GENERATED = 'PLAN_GENERATED'
    PLAN_RUNNING = 'PLAN_RUNNING'
    PREFLIGHT_COMPLETE = 'PREFLIGHT_COMPLETE'
    PRE_FLIGHT_RUNNING = 'PRE_FLIGHT_RUNNING'
    READY_FOR_TAKEOFF = 'READY_FOR_TAKEOFF'
    TAKEOFF_RUNNING = 'TAKEOFF_RUNNING'
    TOKEN_CREATED = 'TOKEN_CREATED'


class LastDecision(Enum):
    allow = 'allow'
    deny = 'deny'
    require_approval = 'require_approval'
    warn = 'warn'


class WorkflowState(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    state: State
    workflow_id: Optional[str] = None
    step_id: Optional[str] = None
    last_decision: Optional[LastDecision] = None
    plan_token_hash: Optional[str] = None


class ApprovalRecord(BaseModel):
    """
    Durable approval record.
    Tracks who approved what, when, bound to specific plan-token hash.
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    approval_id: str
    step_id: str
    plan_token_hash: str
    approved: bool
    approver: str
    approved_at: AwareDatetime
    reason: Optional[str] = None
    evidence_hashes: Optional[list[str]] = None


class ArtifactRecord(BaseModel):
    """
    Durable artifact record.
    Tracks artifacts with SHA256 hashes for integrity verification.
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    artifact_id: str
    step_id: str
    artifact_hash: str
    artifact_type: str
    created_at: AwareDatetime
    metadata: Optional[RecordStringAny] = None


class PolicyEvaluationRecord(BaseModel):
    """
    Durable policy evaluation record.
    Tracks policy decisions with evidence for audit trail.
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    evaluation_id: str
    step_id: str
    policy_name: str
    decision: Decision
    evaluated_at: AwareDatetime
    reason: Optional[str] = None
    evidence_hashes: Optional[list[str]] = None


class WALEntryType(Enum):
    approval_received = 'approval_received'
    approval_requested = 'approval_requested'
    artifact_created = 'artifact_created'
    policy_evaluated = 'policy_evaluated'
    step_completed = 'step_completed'
    step_started = 'step_started'
    workflow_completed = 'workflow_completed'
    workflow_failed = 'workflow_failed'
    workflow_started = 'workflow_started'


class WorkflowStartedData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    plan_token_hash: str
    initial_state: State


class StepStartedData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    step_id: str
    step_type: str


class StepCompletedData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    step_id: str
    artifacts: Optional[list[str]] = None


class ApprovalRequestedData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    approval_id: str
    step_id: str
    required_role: str


class ApprovalReceivedData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    approval_id: str
    approved: bool
    approver: str


class ArtifactCreatedData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    artifact_id: str
    artifact_hash: str
    artifact_type: str


class PolicyEvaluatedData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    evaluation_id: str
    policy_name: str
    decision: Decision


class WorkflowCompletedData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    final_state: State
    artifacts: list[str]


class WorkflowFailedData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    error: str
    failed_step: Optional[str] = None


class AuditWorkflow(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    workflow_id: Optional[str] = None
    step_id: Optional[str] = None
    mode: Optional[str] = None


class AuditEngine(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    engine_id: Optional[str] = None
    receipt_id: Optional[str] = None
    status: Optional[str] = None
    error: Optional[str] = None


class AuditArtifact(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Optional[str] = None
    role: Optional[str] = None
    path: Optional[str] = None
    hash: Optional[str] = None
    size: Optional[float] = None


class AggregationMethod(Enum):
    """
    Policy aggregation strategy.
    Defines how multiple policy decisions are combined into a final decision.
    """

    all_allow = 'all_allow'
    any_deny = 'any_deny'
    custom = 'custom'
    majority = 'majority'
    most_restrictive = 'most_restrictive'
    unanimous = 'unanimous'


class DecisionSeverity(Enum):
    """
    Decision severity for ordering.
    Used to determine "most restrictive" in aggregation.
    """

    number_0 = 0
    number_1 = 1
    number_2 = 2
    number_3 = 3


class AggregationMethod1(Enum):
    """
    Aggregation method used to combine individual policy decisions.
    REQUIRED if multiple policies were evaluated.
    Ensures deterministic aggregation across orchestrators.
    """

    all_allow = 'all_allow'
    any_deny = 'any_deny'
    custom = 'custom'
    majority = 'majority'
    most_restrictive = 'most_restrictive'
    unanimous = 'unanimous'


class Source(Enum):
    """
    Policy source type.
    """

    custom = 'custom'
    llm_gateway = 'llm_gateway'
    mcp_gateway = 'mcp_gateway'
    onnx = 'onnx'
    opa = 'opa'


class PolicyEvaluation(BaseModel):
    """
    Individual policy evaluation result.
    Captures decision source and evidence.
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    source: Source
    """
    Policy source type.
    """
    policy_id: str
    """
    Policy identifier (e.g., OPA policy name, ONNX model name).
    """
    decision: Decision
    """
    Decision from this specific policy.
    """
    severity: DecisionSeverity
    """
    Decision severity for aggregation ordering.
    0=allow, 1=warn, 2=require_approval, 3=deny
    REQUIRED for deterministic "most restrictive" aggregation.
    """
    reason: Optional[str] = None
    """
    Reason for this decision.
    """
    evidence: Optional[RecordStringAny] = None
    """
    Evidence supporting this decision (e.g., rule matches, model scores).
    """
    evaluated_at: AwareDatetime
    """
    Evaluation timestamp.
    """


class AuditApproval(BaseModel):
    """
    Audit record for approval events.
    Extended to ensure approval binding is auditable.
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    approval_id: str
    """
    Unique approval identifier.
    REQUIRED to correlate request and response.
    """
    required_role: str
    """
    Required role for this approval.
    REQUIRED to verify authorization.
    """
    approved: bool
    """
    Whether approval was granted.
    REQUIRED for audit trail.
    """
    approver: str
    """
    Identity of the approver.
    REQUIRED for accountability.
    """
    plan_token_hash: str
    """
    SHA256 hash of the plan-token this approval is bound to.
    REQUIRED to prove approval binding and prevent replay attacks.
    """
    timestamp: AwareDatetime
    """
    ISO 8601 timestamp when approval was granted/denied.
    REQUIRED for temporal ordering.
    """
    reason: Optional[str] = None
    """
    Optional reason for approval/denial.
    """


class AuditIntegrity(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expected_plan_token: Optional[str] = None
    actual_plan_token: Optional[str] = None
    plan_token_match: Optional[bool] = None
    artifacts_match: Optional[bool] = None
    differences: Optional[list[str]] = None


class PolicyDecision(Enum):
    allow = 'allow'
    deny = 'deny'
    require_approval = 'require_approval'
    warn = 'warn'


class AuditGateway(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    gateway_type: Optional[str] = None
    request_id: Optional[str] = None
    model: Optional[str] = None
    tool: Optional[str] = None
    policy_decision: Optional[PolicyDecision] = None


class Severity(Enum):
    critical = 'critical'
    debug = 'debug'
    error = 'error'
    info = 'info'
    warning = 'warning'


class EngineMeta(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    workflow_id: str
    step_id: str


class EngineOrchestrator(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    run_index: Optional[float] = None
    workspace_hash: Optional[str] = None
    artifacts_salt: Optional[str] = None


class EngineArtifact(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: str
    role: str
    path: str
    hash: str
    size: Optional[float] = None


class EngineMetric(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: str
    value: float
    tags: Optional[dict[str, Any]] = None


class Status(Enum):
    """
    Execution status: 'success' or 'failure'.
    """

    failure = 'failure'
    success = 'success'


class LLMGatewayRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    request_id: str
    timestamp: AwareDatetime
    source: Optional[str] = None
    model: str
    provider: Optional[str] = None
    input: RecordStringAny
    context: Optional[RecordStringAny] = None


class GatewayApproval(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    approval_id: Optional[str] = None
    required_role: Optional[str] = None
    reason: Optional[str] = None


class LLMGatewayResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    request_id: str
    timestamp: AwareDatetime
    decision: Decision
    warnings: Optional[list[str]] = None
    violations: Optional[list[str]] = None
    approval: Optional[GatewayApproval] = None
    routed_model: Optional[str] = None
    rewritten_input: Optional[RecordStringAny] = None
    gateway_payload: Optional[RecordStringAny] = None


class LLMGatewayRule(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    match: RecordStringAny
    action: str
    metadata: Optional[RecordStringAny] = None


class LLMGatewayPolicyConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    opa_policies: Optional[list[str]] = None
    onnx_models: Optional[list[str]] = None
    model_routing: Optional[RecordStringAny] = None
    rules: Optional[list[LLMGatewayRule]] = None


class MCPGatewayRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    request_id: str
    timestamp: AwareDatetime
    source: Optional[str] = None
    server_id: str
    method: str
    params: Optional[RecordStringAny] = None
    context: Optional[RecordStringAny] = None


class MCPGatewayResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    request_id: str
    timestamp: AwareDatetime
    decision: Decision
    warnings: Optional[list[str]] = None
    violations: Optional[list[str]] = None
    approval: Optional[GatewayApproval] = None
    rewritten_request: Optional[RecordStringAny] = None


class MCPGatewayRule(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    match: RecordStringAny
    action: str
    metadata: Optional[RecordStringAny] = None


class MCPGatewayPolicyConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    opa_policies: Optional[list[str]] = None
    onnx_models: Optional[list[str]] = None
    rules: Optional[list[MCPGatewayRule]] = None


class Artifact(BaseModel):
    """
    Canonical artifact interface.
    Defined in schemas/draft/artifact.schema.json
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    artifact_type: str
    """
    Type of artifact (file, diff, patch, action, message, etc). Free-form and engine-defined.
    """
    action: str
    """
    Operation to perform with this artifact (create, update, delete, apply, execute, etc). Free-form and engine-defined.
    """
    target: Optional[str] = None
    """
    Path, resource, or identifier this artifact applies to. Optional.
    """
    mime: str
    """
    MIME type describing content.
    """
    body: Optional[Union[dict[str, Any], list[Any], Optional[str]]] = None
    """
    Inline content for small artifacts.
    Can be string, object, array, or null.
    """
    body_file: Optional[str] = None
    """
    Indicates an external data file within the artifact directory.
    """
    metadata: Optional[RecordStringAny] = None
    """
    Arbitrary metadata. Optional.
    """


class WorkflowStateRecord(BaseModel):
    """
    Durable workflow state record for restart-safety.
    Contains all information needed to deterministically resume workflow execution.
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    workflow_id: str
    current_state: State
    plan_token_hash: str
    created_at: AwareDatetime
    updated_at: AwareDatetime
    steps_completed: list[str]
    steps_pending: list[str]
    approvals: list[ApprovalRecord]
    artifacts: list[ArtifactRecord]
    policy_evaluations: list[PolicyEvaluationRecord]
    metadata: Optional[RecordStringAny] = None


class AuditPolicy(BaseModel):
    """
    Policy evaluation audit record.
    Extended to support chain-of-custody reconstruction.
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    decision: Decision
    """
    Final aggregated decision after all policy evaluations.
    REQUIRED for chain-of-custody.
    """
    policy_evaluations: Optional[list[PolicyEvaluation]] = None
    """
    Individual policy evaluation results.
    Captures which specific policies (OPA/ONNX/gateway) produced which decisions.
    """
    aggregation_method: Optional[AggregationMethod1] = None
    """
    Aggregation method used to combine individual policy decisions.
    REQUIRED if multiple policies were evaluated.
    Ensures deterministic aggregation across orchestrators.
    """
    workflow_state: str
    """
    Workflow state when this policy evaluation occurred.
    REQUIRED for temporal chain-of-custody.
    """
    violations: Optional[list[str]] = None
    """
    Policy violations detected.
    """
    warnings: Optional[list[str]] = None
    """
    Policy warnings (non-blocking).
    """
    engine: Optional[str] = None
    """
    Legacy field for backward compatibility.
    """


class AuditEvent(BaseModel):
    """
    Canonical schema for all audit log events.
    Defined in schemas/draft/audit-event.schema.json
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    event_id: str
    """
    Unique identifier for this audit event.
    """
    timestamp: AwareDatetime
    """
    RFC3339 timestamp of when the event occurred.
    """
    event_type: str
    """
    Free-form event category.
    """
    workflow: Optional[AuditWorkflow] = None
    workflow_state: str
    """
    Workflow state when this event was emitted.
    REQUIRED for temporal chain-of-custody reconstruction.
    """
    engine: Optional[AuditEngine] = None
    plan_token: Optional[PlanToken] = None
    """
    Plan-token binds artifacts to subsequent take-off.
    Extended with version and governance provenance for safe upgrades and auditability.
    """
    artifacts: Optional[list[AuditArtifact]] = None
    policy: Optional[AuditPolicy] = None
    """
    Policy evaluation audit record.
    Extended to support chain-of-custody reconstruction.
    """
    approval: Optional[AuditApproval] = None
    """
    Audit record for approval events.
    Extended to ensure approval binding is auditable.
    """
    integrity_check: Optional[AuditIntegrity] = None
    gateway: Optional[AuditGateway] = None
    signature: Optional[str] = None
    """
    Cryptographic signature of this event hash.
    """
    signature_key_ref: Optional[str] = None
    """
    Reference to the key used for signing (e.g. 'engine-key-1', 'orchestrator-key-prod').
    """
    chain_hash: Optional[str] = None
    """
    Hash of the previous event in the chain. Allows for ledger-style verification.
    """
    message: Optional[str] = None
    severity: Optional[Severity] = None


class EngineInput(BaseModel):
    """
    Input delivered via STDIN or CABINCREW_INPUT_FILE.
    Defined in schemas/draft/engine.schema.json
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    protocol_version: str
    mode: Mode
    """
    Execution mode: 'flight-plan' or 'take-off'.
    """
    meta: EngineMeta
    config: Optional[dict[str, Any]] = None
    secrets: Optional[dict[str, Any]] = None
    allowed_secrets: Optional[list[str]] = None
    context: Optional[dict[str, Any]] = None
    identity_token: Optional[str] = None
    """
    Ephemeral identity token (e.g. OIDC, JWT) for the workload.
    Preferred over static secrets.
    """
    orchestrator: Optional[EngineOrchestrator] = None
    expected_plan_token: Optional[str] = None


class EngineOutput(BaseModel):
    """
    Output delivered via STDOUT or CABINCREW_OUTPUT_FILE.
    Defined in schemas/draft/engine.schema.json
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    protocol_version: str
    engine_id: str
    mode: Mode
    receipt_id: str
    status: Status
    """
    Execution status: 'success' or 'failure'.
    """
    error: Optional[str] = None
    warnings: Optional[list[str]] = None
    diagnostics: Optional[Any] = None
    artifacts: Optional[list[EngineArtifact]] = None
    metrics: Optional[list[EngineMetric]] = None
    plan_token: Optional[str] = None
    """
    SHA256 hash referencing a plan-token.json file.
    """


class WALEntry(BaseModel):
    """
    Write-Ahead Log entry for deterministic replay.
    Enables crash recovery and multi-orchestrator consistency.
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    sequence: float
    timestamp: AwareDatetime
    workflow_id: str
    entry_type: WALEntryType
    data: Union[
        WorkflowStartedData,
        StepStartedData,
        StepCompletedData,
        ApprovalRequestedData,
        ApprovalReceivedData,
        ArtifactCreatedData,
        PolicyEvaluatedData,
        WorkflowCompletedData,
        WorkflowFailedData,
    ]
    checksum: str
